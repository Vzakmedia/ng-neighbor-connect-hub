diff --git a/node_modules/cordova-plugin-callkit/plugin.xml b/node_modules/cordova-plugin-callkit/plugin.xml
index 4ec73a5..a7bbc7c 100644
--- a/node_modules/cordova-plugin-callkit/plugin.xml
+++ b/node_modules/cordova-plugin-callkit/plugin.xml
@@ -26,7 +26,8 @@
 
         <config-file parent="/manifest/application" target="AndroidManifest.xml">
             <service android:name="com.dmarc.cordovacall.MyConnectionService"
-                    android:permission="android.permission.BIND_TELECOM_CONNECTION_SERVICE">
+                    android:permission="android.permission.BIND_TELECOM_CONNECTION_SERVICE"
+                    android:exported="true">
                 <intent-filter>
                     <action android:name="android.telecom.ConnectionService" />
                 </intent-filter>
diff --git a/node_modules/cordova-plugin-callkit/src/android/CordovaCall.java b/node_modules/cordova-plugin-callkit/src/android/CordovaCall.java
index 53dbd95..7c55b3d 100644
--- a/node_modules/cordova-plugin-callkit/src/android/CordovaCall.java
+++ b/node_modules/cordova-plugin-callkit/src/android/CordovaCall.java
@@ -73,25 +73,27 @@ public class CordovaCall extends CordovaPlugin {
         cordovaWebView = webView;
         super.initialize(cordova, webView);
         appName = getApplicationName(this.cordova.getActivity().getApplicationContext());
-        handle = new PhoneAccountHandle(new ComponentName(this.cordova.getActivity().getApplicationContext(),MyConnectionService.class),appName);
-        tm = (TelecomManager)this.cordova.getActivity().getApplicationContext().getSystemService(this.cordova.getActivity().getApplicationContext().TELECOM_SERVICE);
-        if(android.os.Build.VERSION.SDK_INT >= 26) {
-          phoneAccount = new PhoneAccount.Builder(handle, appName)
-                  .setCapabilities(PhoneAccount.CAPABILITY_SELF_MANAGED)
-                  .build();
-          tm.registerPhoneAccount(phoneAccount);
+        handle = new PhoneAccountHandle(
+                new ComponentName(this.cordova.getActivity().getApplicationContext(), MyConnectionService.class),
+                appName);
+        tm = (TelecomManager) this.cordova.getActivity().getApplicationContext()
+                .getSystemService(this.cordova.getActivity().getApplicationContext().TELECOM_SERVICE);
+        if (android.os.Build.VERSION.SDK_INT >= 26) {
+            phoneAccount = new PhoneAccount.Builder(handle, appName)
+                    .setCapabilities(PhoneAccount.CAPABILITY_SELF_MANAGED)
+                    .build();
+            tm.registerPhoneAccount(phoneAccount);
+        } else if (android.os.Build.VERSION.SDK_INT >= 23) {
+            phoneAccount = new PhoneAccount.Builder(handle, appName)
+                    .setCapabilities(PhoneAccount.CAPABILITY_CALL_PROVIDER)
+                    .build();
+            tm.registerPhoneAccount(phoneAccount);
         }
-        if(android.os.Build.VERSION.SDK_INT >= 23) {
-          phoneAccount = new PhoneAccount.Builder(handle, appName)
-                   .setCapabilities(PhoneAccount.CAPABILITY_CALL_PROVIDER)
-                   .build();
-          tm.registerPhoneAccount(phoneAccount);          
-        }
-        callbackContextMap.put("answer",new ArrayList<CallbackContext>());
-        callbackContextMap.put("reject",new ArrayList<CallbackContext>());
-        callbackContextMap.put("hangup",new ArrayList<CallbackContext>());
-        callbackContextMap.put("sendCall",new ArrayList<CallbackContext>());
-        callbackContextMap.put("receiveCall",new ArrayList<CallbackContext>());
+        callbackContextMap.put("answer", new ArrayList<CallbackContext>());
+        callbackContextMap.put("reject", new ArrayList<CallbackContext>());
+        callbackContextMap.put("hangup", new ArrayList<CallbackContext>());
+        callbackContextMap.put("sendCall", new ArrayList<CallbackContext>());
+        callbackContextMap.put("receiveCall", new ArrayList<CallbackContext>());
 
         instance = this;
     }
@@ -107,8 +109,8 @@ public class CordovaCall extends CordovaPlugin {
         this.callbackContext = callbackContext;
         if (action.equals("receiveCall")) {
             Connection conn = MyConnectionService.getConnection();
-            if(conn != null) {
-                if(conn.getState() == Connection.STATE_ACTIVE) {
+            if (conn != null) {
+                if (conn.getState() == Connection.STATE_ACTIVE) {
                     this.callbackContext.error("You can't receive a call right now because you're already in a call");
                 } else {
                     this.callbackContext.error("You can't receive a call right now");
@@ -122,11 +124,12 @@ public class CordovaCall extends CordovaPlugin {
             return true;
         } else if (action.equals("sendCall")) {
             Connection conn = MyConnectionService.getConnection();
-            if(conn != null) {
-                if(conn.getState() == Connection.STATE_ACTIVE) {
+            if (conn != null) {
+                if (conn.getState() == Connection.STATE_ACTIVE) {
                     this.callbackContext.error("You can't make a call right now because you're already in a call");
-                } else if(conn.getState() == Connection.STATE_DIALING) {
-                    this.callbackContext.error("You can't make a call right now because you're already trying to make a call");
+                } else if (conn.getState() == Connection.STATE_DIALING) {
+                    this.callbackContext
+                            .error("You can't make a call right now because you're already trying to make a call");
                 } else {
                     this.callbackContext.error("You can't make a call right now");
                 }
@@ -135,30 +138,33 @@ public class CordovaCall extends CordovaPlugin {
                 permissionCounter = 2;
                 pendingAction = "sendCall";
                 this.checkCallPermission();
-                /*cordova.getThreadPool().execute(new Runnable() {
-                    public void run() {
-                        getCallPhonePermission();
-                    }
-                });*/
+                /*
+                 * cordova.getThreadPool().execute(new Runnable() {
+                 * public void run() {
+                 * getCallPhonePermission();
+                 * }
+                 * });
+                 */
             }
             return true;
         } else if (action.equals("connectCall")) {
             Connection conn = MyConnectionService.getConnection();
-            if(conn == null) {
+            if (conn == null) {
                 this.callbackContext.error("No call exists for you to connect");
-            } else if(conn.getState() == Connection.STATE_ACTIVE) {
+            } else if (conn.getState() == Connection.STATE_ACTIVE) {
                 this.callbackContext.error("Your call is already connected");
             } else {
                 conn.setActive();
-                Intent intent = new Intent(this.cordova.getActivity().getApplicationContext(), this.cordova.getActivity().getClass());
-                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_SINGLE_TOP);
+                Intent intent = new Intent(this.cordova.getActivity().getApplicationContext(),
+                        this.cordova.getActivity().getClass());
+                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);
                 this.cordova.getActivity().getApplicationContext().startActivity(intent);
                 this.callbackContext.success("Call connected successfully");
             }
             return true;
         } else if (action.equals("endCall")) {
             Connection conn = MyConnectionService.getConnection();
-            if(conn == null) {
+            if (conn == null) {
                 this.callbackContext.error("No call exists for you to end");
             } else {
                 DisconnectCause cause = new DisconnectCause(DisconnectCause.LOCAL);
@@ -169,7 +175,8 @@ public class CordovaCall extends CordovaPlugin {
                 for (final CallbackContext cbContext : callbackContexts) {
                     cordova.getThreadPool().execute(new Runnable() {
                         public void run() {
-                            PluginResult result = new PluginResult(PluginResult.Status.OK, "hangup event called successfully");
+                            PluginResult result = new PluginResult(PluginResult.Status.OK,
+                                    "hangup event called successfully");
                             result.setKeepCallback(true);
                             cbContext.sendPluginResult(result);
                         }
@@ -185,29 +192,32 @@ public class CordovaCall extends CordovaPlugin {
             return true;
         } else if (action.equals("setAppName")) {
             String appName = args.getString(0);
-            handle = new PhoneAccountHandle(new ComponentName(this.cordova.getActivity().getApplicationContext(),MyConnectionService.class),appName);
-            if(android.os.Build.VERSION.SDK_INT >= 26) {
-              phoneAccount = new PhoneAccount.Builder(handle, appName)
-                  .setCapabilities(PhoneAccount.CAPABILITY_SELF_MANAGED)
-                  .build();
-              tm.registerPhoneAccount(phoneAccount);
-            }
-            if(android.os.Build.VERSION.SDK_INT >= 23) {
-              phoneAccount = new PhoneAccount.Builder(handle, appName)
-                   .setCapabilities(PhoneAccount.CAPABILITY_CALL_PROVIDER)
-                   .build();
-              tm.registerPhoneAccount(phoneAccount);
+            handle = new PhoneAccountHandle(
+                    new ComponentName(this.cordova.getActivity().getApplicationContext(), MyConnectionService.class),
+                    appName);
+            if (android.os.Build.VERSION.SDK_INT >= 26) {
+                phoneAccount = new PhoneAccount.Builder(handle, appName)
+                        .setCapabilities(PhoneAccount.CAPABILITY_SELF_MANAGED)
+                        .build();
+                tm.registerPhoneAccount(phoneAccount);
+            } else if (android.os.Build.VERSION.SDK_INT >= 23) {
+                phoneAccount = new PhoneAccount.Builder(handle, appName)
+                        .setCapabilities(PhoneAccount.CAPABILITY_CALL_PROVIDER)
+                        .build();
+                tm.registerPhoneAccount(phoneAccount);
             }
             this.callbackContext.success("App Name Changed Successfully");
             return true;
         } else if (action.equals("setIcon")) {
             String iconName = args.getString(0);
-            int iconId = this.cordova.getActivity().getApplicationContext().getResources().getIdentifier(iconName, "drawable", this.cordova.getActivity().getPackageName());
-            if(iconId != 0) {
+            int iconId = this.cordova.getActivity().getApplicationContext().getResources().getIdentifier(iconName,
+                    "drawable", this.cordova.getActivity().getPackageName());
+            if (iconId != 0) {
                 icon = Icon.createWithResource(this.cordova.getActivity(), iconId);
                 this.callbackContext.success("Icon Changed Successfully");
             } else {
-                this.callbackContext.error("This icon does not exist. Make sure to add it to the res/drawable folder the right way.");
+                this.callbackContext.error(
+                        "This icon does not exist. Make sure to add it to the res/drawable folder the right way.");
             }
             return true;
         } else if (action.equals("mute")) {
@@ -228,15 +238,15 @@ public class CordovaCall extends CordovaPlugin {
             return true;
         } else if (action.equals("callNumber")) {
             realCallTo = args.getString(0);
-            if(realCallTo != null) {
-              cordova.getThreadPool().execute(new Runnable() {
-                  public void run() {
-                      callNumberPhonePermission();
-                  }
-              });
-              this.callbackContext.success("Call Successful");
+            if (realCallTo != null) {
+                cordova.getThreadPool().execute(new Runnable() {
+                    public void run() {
+                        callNumberPhonePermission();
+                    }
+                });
+                this.callbackContext.success("Call Successful");
             } else {
-              this.callbackContext.error("Call Failed. You need to enter a phone number.");
+                this.callbackContext.error("Call Failed. You need to enter a phone number.");
             }
             return true;
         }
@@ -244,21 +254,22 @@ public class CordovaCall extends CordovaPlugin {
     }
 
     private void checkCallPermission() {
-        if(permissionCounter >= 1) {
+        if (permissionCounter >= 1) {
             PhoneAccount currentPhoneAccount = tm.getPhoneAccount(handle);
-            if(currentPhoneAccount.isEnabled()) {
-                if(pendingAction == "receiveCall") {
+            if (currentPhoneAccount.isEnabled()) {
+                if (pendingAction == "receiveCall") {
                     this.receiveCall();
-                } else if(pendingAction == "sendCall") {
+                } else if (pendingAction == "sendCall") {
                     this.sendCall();
                 }
             } else {
-                if(permissionCounter == 2) {
+                if (permissionCounter == 2) {
                     Intent phoneIntent = new Intent(TelecomManager.ACTION_CHANGE_PHONE_ACCOUNTS);
                     phoneIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_SINGLE_TOP);
                     this.cordova.getActivity().getApplicationContext().startActivity(phoneIntent);
                 } else {
-                    this.callbackContext.error("You need to accept phone account permissions in order to send and receive calls");
+                    this.callbackContext
+                            .error("You need to accept phone account permissions in order to send and receive calls");
                 }
             }
         }
@@ -267,7 +278,7 @@ public class CordovaCall extends CordovaPlugin {
 
     private void receiveCall() {
         Bundle callInfo = new Bundle();
-        callInfo.putString("from",from);
+        callInfo.putString("from", from);
         tm.addNewIncomingCall(handle, callInfo);
         permissionCounter = 0;
         this.callbackContext.success("Incoming call successful");
@@ -276,9 +287,9 @@ public class CordovaCall extends CordovaPlugin {
     private void sendCall() {
         Uri uri = Uri.fromParts("tel", to, null);
         Bundle callInfoBundle = new Bundle();
-        callInfoBundle.putString("to",to);
+        callInfoBundle.putString("to", to);
         Bundle callInfo = new Bundle();
-        callInfo.putParcelable(TelecomManager.EXTRA_OUTGOING_CALL_EXTRAS,callInfoBundle);
+        callInfo.putParcelable(TelecomManager.EXTRA_OUTGOING_CALL_EXTRAS, callInfoBundle);
         callInfo.putParcelable(TelecomManager.EXTRA_PHONE_ACCOUNT_HANDLE, handle);
         callInfo.putBoolean(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE, true);
         tm.placeCall(uri, callInfo);
@@ -287,29 +298,33 @@ public class CordovaCall extends CordovaPlugin {
     }
 
     private void mute() {
-        AudioManager audioManager = (AudioManager) this.cordova.getActivity().getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+        AudioManager audioManager = (AudioManager) this.cordova.getActivity().getApplicationContext()
+                .getSystemService(Context.AUDIO_SERVICE);
         audioManager.setMicrophoneMute(true);
     }
 
     private void unmute() {
-        AudioManager audioManager = (AudioManager) this.cordova.getActivity().getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+        AudioManager audioManager = (AudioManager) this.cordova.getActivity().getApplicationContext()
+                .getSystemService(Context.AUDIO_SERVICE);
         audioManager.setMicrophoneMute(false);
     }
 
     private void speakerOn() {
-        AudioManager audioManager = (AudioManager) this.cordova.getActivity().getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+        AudioManager audioManager = (AudioManager) this.cordova.getActivity().getApplicationContext()
+                .getSystemService(Context.AUDIO_SERVICE);
         audioManager.setSpeakerphoneOn(true);
     }
 
     private void speakerOff() {
-        AudioManager audioManager = (AudioManager) this.cordova.getActivity().getApplicationContext().getSystemService(Context.AUDIO_SERVICE);
+        AudioManager audioManager = (AudioManager) this.cordova.getActivity().getApplicationContext()
+                .getSystemService(Context.AUDIO_SERVICE);
         audioManager.setSpeakerphoneOn(false);
     }
 
     public static String getApplicationName(Context context) {
-      ApplicationInfo applicationInfo = context.getApplicationInfo();
-      int stringId = applicationInfo.labelRes;
-      return stringId == 0 ? applicationInfo.nonLocalizedLabel.toString() : context.getString(stringId);
+        ApplicationInfo applicationInfo = context.getApplicationInfo();
+        int stringId = applicationInfo.labelRes;
+        return stringId == 0 ? applicationInfo.nonLocalizedLabel.toString() : context.getString(stringId);
     }
 
     protected void getCallPhonePermission() {
@@ -322,27 +337,25 @@ public class CordovaCall extends CordovaPlugin {
 
     private void callNumber() {
         try {
-          Intent intent = new Intent(Intent.ACTION_CALL, Uri.fromParts("tel", realCallTo, null));
-          this.cordova.getActivity().getApplicationContext().startActivity(intent);
-        } catch(Exception e) {
-          this.callbackContext.error("Call Failed");
+            Intent intent = new Intent(Intent.ACTION_CALL, Uri.fromParts("tel", realCallTo, null));
+            this.cordova.getActivity().getApplicationContext().startActivity(intent);
+        } catch (Exception e) {
+            this.callbackContext.error("Call Failed");
         }
         this.callbackContext.success("Call Successful");
     }
 
     @Override
-    public void onRequestPermissionResult(int requestCode, String[] permissions, int[] grantResults) throws JSONException
-    {
-        for(int r:grantResults)
-        {
-            if(r == PackageManager.PERMISSION_DENIED)
-            {
-                this.callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.ERROR, "CALL_PHONE Permission Denied"));
+    public void onRequestPermissionResult(int requestCode, String[] permissions, int[] grantResults)
+            throws JSONException {
+        for (int r : grantResults) {
+            if (r == PackageManager.PERMISSION_DENIED) {
+                this.callbackContext
+                        .sendPluginResult(new PluginResult(PluginResult.Status.ERROR, "CALL_PHONE Permission Denied"));
                 return;
             }
         }
-        switch(requestCode)
-        {
+        switch (requestCode) {
             case CALL_PHONE_REQ_CODE:
                 this.sendCall();
                 break;
