// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { nativeSyncStorage } from '@/utils/nativeSyncStorage';

const SUPABASE_URL = "https://cowiviqhrnmhttugozbz.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNvd2l2aXFocm5taHR0dWdvemJ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMwNTQ0NDQsImV4cCI6MjA2ODYzMDQ0NH0.BJ6OstIOar6CqEv__WzF9qZYaW12uQ-FfXYaVdxgJM4";

// Get fetch with safety guards for native platforms
// CapacitorHttp is now disabled, so standard fetch works correctly
const getUnpatchedFetch = (): typeof fetch => {
  // Safe fallback chain: stored original -> window.fetch -> throw error
  const originalFetch = (window as any).__originalFetch__;
  
  // Guard against undefined fetch on early native load
  if (originalFetch && typeof originalFetch === 'function') {
    console.log('[Supabase] Using stored original fetch');
    return wrapFetchWithLogging(originalFetch);
  }
  
  if (typeof window !== 'undefined' && typeof window.fetch === 'function') {
    console.log('[Supabase] Using standard window.fetch');
    return wrapFetchWithLogging(window.fetch.bind(window));
  }
  
  console.error('[Supabase] No fetch implementation available!');
  throw new Error('No fetch implementation available');
};

// Wrap fetch with auth request logging for debugging
const wrapFetchWithLogging = (baseFetch: typeof fetch): typeof fetch => {
  
  // Return a wrapped fetch with detailed logging
  return async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
    const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url;
    const method = init?.method || 'GET';
    const isAuthRequest = url.includes('/auth/') || url.includes('gotrue');
    
    // Log auth-related requests in detail
    if (isAuthRequest) {
      console.log(`[Auth Fetch] ${method} ${url}`);
      console.log('[Auth Fetch] Headers:', JSON.stringify(init?.headers || {}, null, 2));
      if (init?.body) {
        try {
          const bodyPreview = typeof init.body === 'string' 
            ? JSON.parse(init.body) 
            : init.body;
          // Redact sensitive fields
          const safeBody = { ...bodyPreview };
          if (safeBody.password) safeBody.password = '[REDACTED]';
          if (safeBody.refresh_token) safeBody.refresh_token = '[REDACTED]';
          console.log('[Auth Fetch] Body:', JSON.stringify(safeBody, null, 2));
        } catch {
          console.log('[Auth Fetch] Body: [non-JSON or FormData]');
        }
      }
    }
    
    const startTime = Date.now();
    
    try {
      const response = await baseFetch(input, init);
      const duration = Date.now() - startTime;
      
      if (isAuthRequest) {
        console.log(`[Auth Fetch] Response: ${response.status} ${response.statusText} (${duration}ms)`);
        
        // Clone response to read body without consuming it
        const clonedResponse = response.clone();
        try {
          const responseBody = await clonedResponse.json();
          // Redact sensitive fields from response
          const safeResponse = { ...responseBody };
          if (safeResponse.access_token) safeResponse.access_token = '[REDACTED]';
          if (safeResponse.refresh_token) safeResponse.refresh_token = '[REDACTED]';
          console.log('[Auth Fetch] Response body:', JSON.stringify(safeResponse, null, 2));
        } catch {
          console.log('[Auth Fetch] Response body: [non-JSON]');
        }
        
        if (!response.ok) {
          console.error(`[Auth Fetch] ERROR: ${response.status} - Request failed`);
        }
      }
      
      return response;
    } catch (error) {
      const duration = Date.now() - startTime;
      
      if (isAuthRequest) {
        console.error(`[Auth Fetch] NETWORK ERROR after ${duration}ms:`, error);
        console.error('[Auth Fetch] Request details:', { url, method });
      }
      
      throw error;
    }
  };
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Detect iOS device
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

// Safe Capacitor detection with defensive fallback
let cachedCapacitor: any = undefined; // undefined means not checked yet

const getCapacitor = () => {
  if (cachedCapacitor !== undefined) {
    return cachedCapacitor;
  }
  
  try {
    console.log('[Supabase] Checking for Capacitor...');
    // Use window.Capacitor which is injected by native runtime
    // This is safer than require() which may cause bundler issues
    const windowCapacitor = (window as any).Capacitor;
    if (windowCapacitor?.isNativePlatform?.()) {
      cachedCapacitor = windowCapacitor;
      console.log('[Supabase] Capacitor found, native:', true);
      return windowCapacitor;
    }
    console.log('[Supabase] Not on native platform (web mode)');
    cachedCapacitor = null;
    return null;
  } catch (error) {
    console.log('[Supabase] Capacitor check failed (web mode)');
    cachedCapacitor = null;
    return null;
  }
};

// Storage adapter - uses synchronous nativeSyncStorage for all platforms
// nativeSyncStorage uses memory cache for immediate sync access,
// with background syncing to Capacitor Preferences on native
const getStorageAdapter = () => {
  console.log('[Supabase] Using nativeSyncStorage adapter');
  return nativeSyncStorage;
};

// Create Supabase client with synchronous storage adapter
const createSupabaseClient = () => {
  console.log('[Supabase] Creating client...');
  
  const storage = getStorageAdapter();
  const customFetch = getUnpatchedFetch();
  
  const clientConfig: any = {
    auth: {
      storage,
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      storageKey: 'neighborlink-auth',
      flowType: 'pkce',
    },
    global: {
      headers: {
        'X-Client-Info': 'neighborlink-native-sync',
        'Cache-Control': 'no-cache',
      },
      // Use original fetch to bypass CapacitorHttp interception
      fetch: customFetch,
    },
    realtime: {
      params: {
        eventsPerSecond: 10,
      },
      heartbeatIntervalMs: 15000,
      reconnectAfterMs: (tries: number) => Math.min(tries * 500, 5000),
    },
  };

  console.log('[Supabase] Client config ready');
  return createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, clientConfig);
};

export const supabase = createSupabaseClient();

// Aggressive session refresh and validation
const validateAndRefreshSession = async () => {
  try {
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error('Session validation error:', error);
      return;
    }
    
    if (session) {
      // Check if token is about to expire (within 5 minutes)
      const expiresAt = session.expires_at ? session.expires_at * 1000 : 0;
      const now = Date.now();
      const fiveMinutes = 5 * 60 * 1000;
      
      if (expiresAt - now < fiveMinutes) {
        console.log('Token expiring soon, refreshing...');
        const { error: refreshError } = await supabase.auth.refreshSession();
        if (refreshError) {
          console.error('Session refresh failed:', refreshError);
        } else {
          console.log('Session refreshed successfully');
        }
      }
    }
  } catch (error) {
    console.error('Error in validateAndRefreshSession:', error);
  }
};

// Add visibility change listener to refresh session when app comes to foreground
if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      console.log('App became visible, validating session');
      validateAndRefreshSession();
    }
  });

  // Monitor localStorage for session changes (multi-tab support)
  window.addEventListener('storage', (event) => {
    if (event.key?.startsWith('sb-') && event.key?.includes('auth-token') || event.key === 'neighborlink-auth') {
      console.log('Auth storage changed, revalidating session');
      validateAndRefreshSession();
    }
  });

  // CRITICAL: Defer initial session validation by 3 seconds
  // This prevents interference with login flow during app startup
  setTimeout(() => {
    console.log('Deferred session validation starting...');
    validateAndRefreshSession();
  }, 3000);
}