// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { nativeSyncStorage } from '@/utils/nativeSyncStorage';

const SUPABASE_URL = "https://cowiviqhrnmhttugozbz.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNvd2l2aXFocm5taHR0dWdvemJ6Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMwNTQ0NDQsImV4cCI6MjA2ODYzMDQ0NH0.BJ6OstIOar6CqEv__WzF9qZYaW12uQ-FfXYaVdxgJM4";

// Get fetch with safety guards for native platforms
// CapacitorHttp is now disabled, so standard fetch works correctly
const getUnpatchedFetch = (): typeof fetch => {
  // Safe fallback chain: stored original -> window.fetch -> throw error
  const originalFetch = (window as any).__originalFetch__;

  // Guard against undefined fetch on early native load
  if (originalFetch && typeof originalFetch === 'function') {
    console.log('[Supabase] Using stored original fetch');
    return wrapFetchWithLogging(originalFetch);
  }

  if (typeof window !== 'undefined' && typeof window.fetch === 'function') {
    console.log('[Supabase] Using standard window.fetch');
    return wrapFetchWithLogging(window.fetch.bind(window));
  }

  console.error('[Supabase] No fetch implementation available!');
  throw new Error('No fetch implementation available');
};

// Wrap fetch with auth request logging for debugging
// Wrap fetch with auth request logging for debugging
const wrapFetchWithLogging = (baseFetch: typeof fetch): typeof fetch => {

  // Return a wrapped fetch
  return async (input: RequestInfo | URL, init?: RequestInit): Promise<Response> => {
    return baseFetch(input, init);
  };
};

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Detect iOS device
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);

// Safe Capacitor detection with defensive fallback
let cachedCapacitor: any = undefined; // undefined means not checked yet

const getCapacitor = () => {
  if (cachedCapacitor !== undefined) {
    return cachedCapacitor;
  }

  try {
    console.log('[Supabase] Checking for Capacitor...');
    // Use window.Capacitor which is injected by native runtime
    // This is safer than require() which may cause bundler issues
    const windowCapacitor = (window as any).Capacitor;
    if (windowCapacitor?.isNativePlatform?.()) {
      cachedCapacitor = windowCapacitor;
      console.log('[Supabase] Capacitor found, native:', true);
      return windowCapacitor;
    }
    console.log('[Supabase] Not on native platform (web mode)');
    cachedCapacitor = null;
    return null;
  } catch (error) {
    console.log('[Supabase] Capacitor check failed (web mode)');
    cachedCapacitor = null;
    return null;
  }
};

// Storage adapter - uses synchronous nativeSyncStorage for all platforms
// nativeSyncStorage uses memory cache for immediate sync access,
// with background syncing to Capacitor Preferences on native
const getStorageAdapter = () => {
  console.log('[Supabase] Using nativeSyncStorage adapter');
  return nativeSyncStorage;
};

// Create Supabase client with synchronous storage adapter
const createSupabaseClient = () => {
  console.log('[Supabase] Creating client...');

  const storage = getStorageAdapter();
  const customFetch = getUnpatchedFetch();

  const clientConfig: any = {
    auth: {
      storage,
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
      storageKey: 'neighborlink-auth',
      flowType: 'pkce',
    },
    global: {
      headers: {
        'X-Client-Info': 'neighborlink-native-sync',
        'Cache-Control': 'no-cache',
      },
      // Use original fetch to bypass CapacitorHttp interception
      fetch: customFetch,
    },
    realtime: {
      params: {
        eventsPerSecond: 10,
      },
      heartbeatIntervalMs: 15000,
      reconnectAfterMs: (tries: number) => Math.min(tries * 500, 5000),
    },
  };

  console.log('[Supabase] Client config ready');
  return createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, clientConfig);
};

export const supabase = createSupabaseClient();

// Aggressive session refresh and validation
const validateAndRefreshSession = async () => {
  try {
    const { data: { session }, error } = await supabase.auth.getSession();

    if (error) {
      console.error('Session validation error:', error);
      return;
    }

    if (session) {
      // Check if token is about to expire (within 5 minutes)
      const expiresAt = session.expires_at ? session.expires_at * 1000 : 0;
      const now = Date.now();
      const fiveMinutes = 5 * 60 * 1000;

      if (expiresAt - now < fiveMinutes) {
        console.log('Token expiring soon, refreshing...');
        const { error: refreshError } = await supabase.auth.refreshSession();
        if (refreshError) {
          console.error('Session refresh failed:', refreshError);
        } else {
          console.log('Session refreshed successfully');
        }
      }
    }
  } catch (error) {
    console.error('Error in validateAndRefreshSession:', error);
  }
};

// Add visibility change listener to refresh session when app comes to foreground
if (typeof document !== 'undefined') {
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') {
      console.log('App became visible, validating session');
      validateAndRefreshSession();
    }
  });

  // Monitor localStorage for session changes (multi-tab support)
  window.addEventListener('storage', (event) => {
    if (event.key?.startsWith('sb-') && event.key?.includes('auth-token') || event.key === 'neighborlink-auth') {
      console.log('Auth storage changed, revalidating session');
      validateAndRefreshSession();
    }
  });

  // CRITICAL: Defer initial session validation by 3 seconds
  // This prevents interference with login flow during app startup
  setTimeout(() => {
    console.log('Deferred session validation starting...');
    validateAndRefreshSession();
  }, 3000);
}